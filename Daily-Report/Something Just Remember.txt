1. 非匿名自执行函数，函数名只读。 （function a(){ a = 2; console.log(a) }）（）  // IIFE 中是一个具名函数 此时相当于(const a = function() { a= 1; console.log(a) })()

2. 实例对象的隐试原型 == 构造函数的显示原型

3. 作用域链  用来找变量的 -> 先从当前上下文变量对象中查找 没有找到 就会朝着父级执行上下文的变量对象查找 一直找到全局对象 这样由多个执行上下文的变量对象构成的链表 就是 作用域链

4.对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。引用计数（现代浏览器不再使用）标记清除（常用）
引用计数有一个致命的问题 - 循环引用

5.   .的优先级高于=

6.四种常见的JS内存泄漏 1、意外的全局变量  2、被遗忘的计时器或回调函数  3、闭包   4、脱离 DOM 的引用

7.闭包的关键是匿名函数可以访问父级作用域的变量。

8. 找变量和找this 不同  变量和从哪调没关系 按照作用域找。 this和从哪定义没关系 从哪调this就指向哪！

9. IIFE 中 this 指向window

10.箭头函数的this指向外层作用域，并不一定是第一层，也不一定是第二层。因为没有自身的this，所以只能根据作用域链往上层查找，
直到找到一个绑定了this的函数作用域，并指向调用该普通函数的对象。