重绘&重排

浏览器的渲染机制

1. DOM -> DOM, CSS -> CSSDOM,  DOM+CSSDOM -> Rrnder Tree
2. 有了Render Tree 以后 浏览器就知道了对于DOM的其所有的样式
3. 根据样式中的属性 计算出DOM元素的大小和位置 进行重排
4. 根据其他属性得到DOM 元素其他的样式进行绘制
5. Display: GPU 进行展示

PS 因为浏览器使用流式布局 所以大部分情况下只需要对Render Tree遍历一次就可以完成，但是Table布局会花费3倍多与同等元素的时间，所以避免使用Table布局！

重排

对于DOM元素，浏览器解析以后 得到了元素的大小和位置 但是还需要计算元素在Viewport上的位置和具体大小 这个过程就是重排

简单来说 就是DOM 元素的 CSS属性会影响页面的排列和布局 这就是重排

重绘

简单来说 由于DOM元素的CSS属性发送变化而进行重新绘制 但是不会影响页面的排列和布局 就是重绘

***** 重排一定会引起重绘  但是重绘不一定引起重排 *****

何时发生重绘重排？？？

1. 动态添加或删除可见的DOM元素
2. 元素的位置发生变化
3. 元素的尺寸发生变化（大小 内外边距 border）
4. 内容发生变化 例如对于一个没有固定大小的img标签 图片从一张大图换到了一张小图
5. 第一次加载页面不可避免的会有重绘和重排
6. 浏览器resize 放大或者缩小时

如何优化？？？
1. JS 中避免频繁的操作样式和DOM
2. 如果需要JS 控制DOM和样式 尽量合并到一起进行批量操作 尽量不要在多个文件或者多个位置进行修改 
3. 使用CSS3 硬件加速 具体代码可以百度（一些编辑器自带） 可以减少动画方面的例如transform的重排和回流 但是对于bg-color类的还是会发生重绘
4. 避免触发同步布局事件 不要频繁对一个DOM的属性进行读取，如果需要此属性可以创建一个变量进行保存
const width = box.offsetWidth;
function initP() {
    for (let i = 0; i < paragraphs.length; i++) {
        paragraphs[i].style.width = width + 'px';  // 这里使用width 代替  box.offsetWidth
    }
}
5. 对需要动画属性的DOM元素使用绝对定位方法使其脱离文档流， 试想一下 如果一个脱离文档流的元素再怎么做transform，也不会影响在文档流里的元素的排列和布局。
6. 避免使用CSS表达式，可能会引发回流。